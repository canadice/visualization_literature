---
title: "732G45 - Visualisering Material"
author: "Isak Hietala"
date: "2019-09-23, version 0.6"
output: 
  bookdown::html_document2: 
    fig_caption: yes
    number_sections: yes
    toc_depth: 3
    toc: yes
    toc_float: 
      collapsed: yes
      smooth_scroll: yes
    theme: readable
  
lang: sv

runtime: shiny

bibliography: visualization.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.height = 2, fig.align = "center", fig.width = 6)

require(ggplot2)
require(grid)
require(gridExtra)
require(RColorBrewer)


require(kableExtra)

source("hietala_theme.R")

# rsconnect::deployDoc(doc = "Visualization Literature/732G45_Visualisering_Material.Rmd", appName = "732G45_visualisering_material", appTitle = "Material used for the course visualization part of 732G45", forceUpdate = TRUE)

```


# Introduktion
Denna sida ämnar att ge ett underlag för visualiseringsmomenten i kursen 732G45. Sidan är under uppbyggnad för höstterminen 2019.

## Varför är visualisering viktigt?
*"En bild säger mer än tusen ord"* är ett vanligt förekommande ordspråk som innehåller mycket sanning. Speciellt när det kommer till information används visualiseringar i olika former för att på ett effektivt och tydligt sätt förmedla stora mängder data som hade varit svårare att uppfatta som enskilda siffror.

Visualisering ger en statistiker möjlighet att lära känna sitt datamaterial innan mer djupgående analys påbörjas. Med mycket data är det oftast svårt få grepp om sina variabler och observationer. Frågor som; "vad är sambandet mellan mina variabler?" eller "finns det några felaktigheter i materialet?" blir mycket enklare att besvara med hjälp av visualiseringar.

Om du ska presentera något banbrytande för dina kollegor eller chefer måste du på något sätt kunna sammanfatta resultatet på ett lättförståeligt och tydligt sätt. Visualiseringar är ett verktyg som ger många möjligheter att komprimera informationen som ska förmedlas.

# Introduktion till programvaror {.tabset}
I resten av denna text kommer exempel visas i tre olika programvaror. Här följer en kortare presentation av dessa.

## R och RStudio {-}
R är ett programmeringsspråk som används väldigt frekvent inom statistikområdet. Det gränssnitt som oftast används för att "prata" med språket är RStudio.

I det nedre högra fönstret kan du välja att antingen navigera runt bland mapparna på datorn, titta på utskrivna diagram, hitta olika paket som kan installeras samt använda hjälpfunktionen. Det smidigaste sättet att få hjälp med en viss funktion är att skriva till exempel `?geom_bar` och sedan trycka på Enter-tangenten i *Console*-fönstret, så kommer hjälpdokumentation till funktionen `geom_bar()` upp i nedre högra fönstret. 

I samma fönster kan du även definiera för RStudio i vilken mapp du har de filer som kommer användas. Notera att de filer du importerar samt de koder du sparar måste vara i denna mapp, samt att sökvägen till mappen inte får innehålla bokstäverna Å, Ä eller Ö. Bestäm sökvägen genom att att använda setwd(). Förslagsvis skapar du en ny mapp med lämpligt namn på din hemkatalog som du har dina filer i.

För att öppna ett textdokument där du kan skriva kod **som sedan sparas som en separat fil** går du menyvägen `File -> New File -> R Script`. Du kan även öppna en ny flik i detta fönster där annan kod kan skrivas, genom att gå till samma menyväg igen.

#### Grundläggande programmering i R {-}
Det första som du bör göra när du startar en ny session i R, och har öppnat ett nytt R Script, är att ange en s.k. *arbetsmapp*. Detta är en mapp på datorn som innehåller de filer som du vill arbeta med under sessionen. Fördelen med att lägga alla filer i en och samma mapp och ange en arbetsmapp i R är att du undviker att ange långa sökvägar till filerna om du vill importera dessa till R. 

För att hitta sökvägen till mappen på din dator som du sparat ner alla dina filer, behöver du öppna upp mappen i ditt operativssystems filhanterare och följa någon av följande instruktioner [instruktioner för Windows](https://www.top-password.com/blog/tag/how-to-find-file-path-windows-10/) / [instruktioner för Mac](http://osxdaily.com/2013/06/19/copy-file-folder-path-mac-os-x/). Kopiera denna sökväg och använd sedan funktionen `setwd()` för att R ska riktas mot rätt mapp på datorn. **Notera att alla `\` måste bytas ut med antingen `\\` eller `/` för att R ska kunna läsa av sökvägen korrekt.**

```{r, eval = FALSE}
## Anger en arbetsmapp på datorn med alla filer som ska användas 
setwd("C:/Users/namn/mapp")

```

R använder sig utav s.k. *paket* med redan skapade funktioner som du kan använda dig utav för att förenkla din programmering. För att dessa funktioner ska kunna användas i din session måste du säga till R att paketet ska laddas upp i sessionen. Du kan tänka det som att du vid din arbetsbänk plockar fram en verktygslåda innehållande de verktyg som du kommer vilja använda under ditt arbete. Om du inte har verktygslådan bredvid dig kommer det bli svårt att använda något av verktygen. Laddningen av paketen kan göras med antingen funktionen `library()` eller `require()`. 

Om du har en ny installation av R på datorn måste du först installera paketen på datorn (ladda ner alla filer som behövs från internet). Det är inte svårare än att använda funktionen `install.packages()` med paketets namn inuti `""` enligt koden nedan. **Detta behöver endast göras en gång för nya installationer av R!**

```{r, eval = FALSE}
## Om paketen inte finns på datorn måste de installeras. KÖRS ENDAST EN GÅNG!
install.packages("ggplot2")
install.packages("RColorBrewer")

## Laddar paketen innehållande de funktioner som vi vill använda
require(ggplot2)
require(RColorBrewer)

```

Termen *funktion* har använts frekvent tidigare i texten och kan behöva förtydligas. En funktion är strukturerad på följande sätt:
\newline

`funktionens_namn(*argument* som styr vad funktionen gör, separerade med kommatecken)`

\newline

Argumentens värden anges med `=` till skillnad från "vanlig" kodning där `<-` anges för att tilldela värden. En funktion börjar med en `(` och slutar men en `)`. Detta betyder att man kan skriva en funktion på både en eller flera rader. Notera att R dock måste ha någon form utav indikation att funktionen fortsätter, t.ex. ett `,` för att ange att flera argument tillkommer eller ett `+` för att koppla ihop flera funktioner, likt som kommer presenteras nedan för `ggplot2`-paketet.

För att lägga till värden i R som *variabler* för sedan kan användas för vidare analys kan nedan kod göras:
```{r, eval = FALSE}
## Siffror anges bara som de är
valfritt_nummer <- 3

## För att man ska ange text måste de omfattas av " " för att R ska läsa de som text
valfri_text <- "Hello world!"

## En vektor med värden
A <- c(3, 5, 3, 7)

B <- c(1, 3, 2, 4)

## En matris med värden
A_2 <- matrix(A, nrow = 2)

## Matematiska beräkningar kan sedan utföras med tidigare skapade variabler.
C <- A + B

D <- A * B

procent <- D / sum(D) * 100

## En vektor med textstränger
ord <- c("Apelsin", "Banan", "Citron")

```

#### Ladda in material {-}
För att kunna arbeta med datamaterial som du samlat in från någon annanstans används någon av `read.()`-funktionerna. Det vanligaste sättet att göra det är genom att skapa en kommaseparerad fil via exempelvis Excel och sedan importera den till R via `read.csv2()`. **Se till att kolumn- och decimalseparatorn anges enligt det format som filen har med `sep = `, och `dec = `.** Ett tips är att öppna *.csv*-filen i **Notepad++** eller annan enkel ordbehandlare för att se vilka symboler som används.

```{r, eval = FALSE}

## Laddar in datamaterial
bil <- read.csv2("D1bil.csv", dec = ".")
elev <- read.csv2("D1elev.csv", dec = ".")

```


## SAS Enterprise Guide {-}
SAS Enterprise Guide (förkortat SAS EG) är det grafiska gränssnitt som öppnar upp användandet av majoriteten av kraftfulla funktioner som programvaran SAS erbjuder för lättare användning. (@SAS2019) Användaren behöver inte kunna programmera utan kan förlita sig på det point-and-click system som finns till hands med översiktliga flödescheman för arbetsprocesser och möjligheten att skapa automatiserade rapporter. (@SASEG2019)

#### Komma igång med ett projekt {-}
När du startat programmet måste du starta ett nytt projekt via `New Project` i välkomstrutan. För att importera filer för vidare analys klickar du på `File -> Import Data`. När du sökt dig fram till den fil som du vill importera kan en del val göras för att hjälpa SAS EG veta vilken sorts variabler som filen har. SAS är generellt bra på att läsa av detta automatiskt men det kan alltid vara bra att kontrollera detta innan du klickar på `Finish`.

För att du ska ha möjlighet att redigera de diagram som du kommer skapa **måste** du vid varje nytt projekt (och ibland när du startar om programmet) klicka dig fram till `Tools -> Options -> Results` och bocka bort `SAS Report` till förmån för `HTML`.

## SPSS {-}
Förkortningen SPSS stod tidigare för Statistical Package for the Social Sciences men används nu frekvent även inom andra områden, framförallt inom hälsovården.

#### Komma igång med ett projekt {-}
När SPSS öppnas så kommer det direkt upp en dialogruta. Dubbelklicka på `Open another file…` i den övre rutan och öppna den fil som du ska arbeta med. Därefter öppnas två fönster: `Viewer` och `Data Editor`. Det senare fönstret liknar mycket ett arbetsblad från Excel men har olika olika flikar som visar antingen observationerna eller en översikt över variablerna som materialet innehållet. I `Variable View` kan du ändra vilken typ och skala som variablerna har ifall importeringen av datamaterialet inte blivit korrekt. 

För att skapa diagram, klickar du på menyn `Graphs` och välj `Chart Builder…`. I dialogrutan som öppnas väljs diagramtyp (dubbelklicka på bilderna) och därefter kommer det upp en ruta där inställningar för diagrammet görs. När diagrammet är färdigt dyker det upp i `Viewer` där du kommer behöva redigera diagrammet ytterligare genom att dubbelklicka på det. **Vid kopiering till en rapport, bör du kopiera från `Viewer`!**

# Visualisering

## Grundläggande begrepp
Ett diagram innehåller olika delar som kommer refereras i resterande text. Här följer en kortare ordlista:

- **Diagramyta**: Det område som innehåller all information tillhörande en visualisering
- **Rityta**: Det område som innehåller det faktiska data som visualiseras
- **Axel**: Kanterna som begränsar ritytan, ofta benämnt som x- och y-axel för den vågräta ( - ) respektive lodräta ( | ) axeln
- **Axelförklaring**: En rubrik som beskriver vad den angivna axeln visar för information
- **Skalvärden**: Steg som anger specifika värden på den angivna axeln
- **Stödlinjer**: Linjer vilka agerar som en förlängning av axlarnas skalvärden i bakgrunden av ritytan
- **Titel/rubrik**: En rubrik för diagrammet
- **Källhänvisning**: En text placerade i någon av de nedre hörnen som anger en källa för det visualiserade datamaterialet om sådan finns

## Ett bra diagram
För att skapa ett bra diagram behöver man tänka på några olika saker.

Vilken typ av variabel som ska visualiseras påverkar huruvida ett diagram är tydligt eller inte. Samma sorts diagram kan mycket enkelt och tydligt visualisera en kvalitativ variabel men visualiserar kvantitativa variabler värdelöst...

```{r echo = FALSE, fig.cap = "Exempel på stapeldiagram för en kvalitativ (t.vä.) och kvantitativ (t.hö.) variabel", fig.width = 8}

data(iris)

p1 <- ggplot(iris) + aes(x = Species) + geom_bar(width = 0.6) +
  labs(y = "Antal", x = "Art")

p2 <- ggplot(iris) + aes(x = Petal.Length) + geom_bar() +
  labs(y = "Antal", x = "Bladlängd")

grid.arrange(p1, p2, nrow = 1)

```

Ritytan innehåller den information som ska förmedlas och bör därför få ta upp majoriteten av platsen i ett diagram. Om man anger för stora rubriker blir det lätt att man inkräktar på ritytan. Detsamma gäller om y-axeln innehåller långa skalvärdesnamn.

```{r echo = FALSE, fig.cap = "Exempel på diagram med majoriteten rityta (t.vä.) och för liten rityta (t.hö.)", fig.width = 8}

p1 <- ggplot(iris) + aes(x = Species) + geom_bar(width = 0.6) +
    labs(y = "Antal", x = "Art")

p2 <- ggplot(iris) + aes(x = Species) + geom_bar(width = 0.6) +
  labs(y = "Antalet blommor av olika arter", x = "Art")

grid.arrange(p1, p2, nrow = 1)

```

Stödlinjer bör finnas för att underlätta utläsningen av information långt från respektive axel. Dessa bör dock inte ta över diagrammet utan enbart finnas i bakgrunden. Notera att stödlinjer kan komma att justera beroende på vilket sammanhang diagrammen används till. Beroende på upplösning, ljusstyrka eller andra skärmegenskaper kan ibland ljusa och smala linjer försvinna in i den vita bakgrunden. Då är tjockare och starkare stödlinjer befogat.

```{r echo = FALSE, fig.cap = "Exempel på stödlinjer som ligger i bakgrunden (t.vä.) och stödlinjer som stjäl fokus från informationen (t.hö.)", fig.width = 8}

p1 <- ggplot(iris) + aes(x = Species) + geom_bar(width = 0.6) +
    labs(y = "Antal", x = "Art")

p2 <- p1 + theme(panel.grid.major.y = element_line(color = "black"),
                 panel.grid.minor.y = element_line(color = "black"))

grid.arrange(p1, p2, nrow = 1)

```

Ett bra diagram har också läsbar text oavsett storleken på diagrammet. En bra referens kan vara att förhålla den minsta texten i diagrammet till ungefär samma storlek som brödtexten i rapporten eller presentationen. Försök att alltid tänka på att underlätta för läsaren!

```{r echo = FALSE, fig.cap = "Exempel på läsbar text (t.vä.) och på gränsen till för liten text (t.hö.)", fig.width = 8}

p1 <- ggplot(iris) + aes(x = Species) + geom_bar(width = 0.6) +
    labs(y = "Antal", x = "Art") 

p2 <- p1 + theme(axis.text = element_text(size = 8, color = "black"),
                 axis.title.y = element_text(angle = 0, vjust = 0.5, size = 9),
                 axis.title.x = element_text(size = 9))

grid.arrange(p1, p2, nrow = 1)

```

Källhänvisning bör finnas i alla diagram där informationen är hämtat från någon annan källa än oss själva. 

```{r echo = FALSE, fig.cap = "Exempeldiagram med källhänvisning", fig.width = 4}

ggplot(iris) + aes(x = Species) + geom_bar(width = 0.6) +
  labs(y = "Antal", x = "Art", caption = "Källa: Fisher, R. A. (1936)")

```


## Visualisering av beskrivande statistik

### Stapeldiagram {.tabset} 
Den absolut enklaste formen av visualisering är stapeldiagram. Denna diagramtyp består utav staplar vars höjd kommer från ett värde i datamaterialet, vanligtvis då man har en kvalitativ variabel och dess frekvenser (antalet av de olika arterna i diagrammen från tidigare kapitel), men diagramtypen kan också användas då man har en kvantitativ variabel uppdelad på en eller flera kvalitativa variabler (medellönen uppdelat på olika sektorer). Följande exempel kommer utgå från det första fallet.

Olika programvaror kräver olika mycket bearbetning av datamaterialet innan diagrammet kan skapas. Vissa kräver att du själv skapar en frekvenstabell och anger att höjden av respektive stapel ska bestämmas av den tillhörande frekvensen, medan andra kan göra dessa beräkningar direkt på rådata.

#### R 
Som tidigare nämnt om R använder sig programmet av diverse paket som innehåller redan skapade funktioner för att lösa diverse arbetsuppgifter. För visualisering kommer vi använda oss främst av paketet `ggplot2` som bygger på vad som kallas för *grammar of graphics*. (@ggplot2019) Detta är ett försök till att formalisera ett språk för hur man enhetligt bör "skriva" visualiseringar och även SPSS använder sig av grunderna till detta språk. Det första steget för att få ta del av funktionerna är att ladda paketet till din R-session genom:

```{r}
require(ggplot2)
```

Paketets visualiseringar utgår ifrån en `data.frame` vilket innebär att vi behöver ladda in ett datamaterial innan vi kan påbörja visualiseringarna. Detta kan göras med någon utav funktionerna `read.csv()`, `read.csv2()` osv. **Se till att datamaterialet som laddats in ser ut som vi förväntar att det ska göra**, exempelvis är decimaler korrekt angivna, har vi lika många variabler i R som i Excel och liknande. Med koden nedan kan datamaterialet som används som exempel genom hela denna text laddas in i R till objektet som kallas `exempeldata`. Vi kan även se hur materialet ser ut genom att använda `head()` som skriver ut ett antal observationer. Materialet ser ut att innehålla fem variabler, varav två är kvalitativa.

```{r}

exempeldata <- read.csv2(file = "732G45_exempeldata.csv")

head(exempeldata, n = 5)

```


##### Grundkomponenter 
Vi kan nu börja med att skapa stapeldiagrammet. Vi börjar med de tre grundkomponenterna av ett `ggplot`-diagram; `ggplot()`, `aes()` och `geom()`. Alla diagram måste innehålla dessa tre komponenter i någon form för att vi ska kunna producera något överhuvudtaget, sen kan vi lägga till andra instruktioner för att ändra diagrammet utseende.

```{r echo = FALSE}
theme_set(theme_gray())
```


I `ggplot()` anges vilket datamaterial vi vill använda för visualiseringen:

```{r}

ggplot(exempeldata)

```

Som vi ser skapas inget utifrån detta kommando, vi har bara sagt åt R att använda datamaterialet men inte vad den ska göra med det. Nästa steg är att ange vilka variabler vi vill använda för axlarna i diagrammet. När det kommer till stapeldiagram finns två olika sätt att göra; antingen har vi rådata och låter R räkna ut frekvensen av de olika kategorierna själv eller så skapar vi en egen frekvenstabell och anger `y = frekvens`. Vi kommer först börja med exemplet utifrån rådata:

```{r}

ggplot(exempeldata) + aes(x = bil)

```

Nu ser vi att R ritat ut de olika bilarna som finns i materialet på x-axeln, men vi har fortfarande inte sagt åt R vad vi vill att den ska göra med informationen vi ska visualisera. Den sista grundkomponenten är den som styr vilken diagramtyp vi skapar och i `ggplot2` finns många olika som vi kommer stöta på i denna text. För ett stapeldiagram anger vi `geom_bar()` från engelska termen *bar chart*. 

```{r}

ggplot(exempeldata) + aes(x = bil) + geom_bar()

```

För att y-axeln ska visa relativa frekvenser istället för absoluta, kan vi i `geom_bar()` lägga till koden `aes(y = stat(count/sum(count)))`. Diagrammet ändrar sig inte i sin form, staplarna är fortfarande lika höga i relation till varandra, men tolkningar av detta diagram kan nu göras i andelar (procent) istället för antal.

```{r}

ggplot(exempeldata) + aes(x = bil) + geom_bar(aes(y = stat(count/sum(count))))

```

Med dessa grundkomponenter får vi fram ett diagram, men vi kan väl alla hålla med om att det i detta läge inte ser särskilt snyggt och tydligt ut. Ett snabbt och enkelt sätt att få till lite snyggare diagram är att använda någon utav `ggplot`s teman som finns tillgängliga genom olika `theme()`. Exempelvis är ett stilrent tema att utgå ifrån `theme_bw()` likt:

```{r}

ggplot(exempeldata) + aes(x = bil) + geom_bar(aes(y = stat(count/sum(count)))) + theme_bw()

```

Det är nu den största funktionaliteten med `ggplot2` kommer in. Vi kan spara instruktionerna vi gett åt R för att skapa diagrammet och senare lägga till fler instruktioner med andra funktioner genom att använda `+` på samma sätt som koderna ovan är skrivna. Vi sparar därför de nuvarande instruktionerna i ett objekt som vi kallar för `p` (vi kan döpa denna till vad som helst) likt:

```{r}

p <- ggplot(exempeldata) + aes(x = bil) + geom_bar(aes(y = stat(count/sum(count)))) + theme_bw()

```

Nu ligger alla instruktioner för **hur** R ska rita upp diagrammet sparat i `p` men för att R också ska producera diagrammet måste vi också säga det likt:

```{r}

p

```

Vi kan nu lägga till ytterligare funktioner exempelvis:

```{r}

p + coord_flip()

```

eller:

```{r}

p + scale_y_continuous(labels = scales::percent)

```

Notera att diagrammet inte roterades i det andra diagrammet när vi ändrade hur skalvärdena på y-axeln ser ut. Detta är för att vi endast sagt åt R att rita diagrammet med vardera tillagda instruktion vid två olika tillfällen utan att ha sparat de någonstans. För att R ska spara dessa instruktioner tillsammans med grundkomponenterna vi angivit innan måste vi spara ovanstående kod till ett objekt:

```{r}

p <- p + scale_y_continuous(labels = scales::percent)

p

```

###### Sammanställd data 
Om vi istället för rådata har sammanställd data exempelvis i form utav en frekvenstabell kan vi ändå skapa samma ovanstående diagram. Vi tänker oss att data om bilarna istället för de `r nrow(exempeldata)` observationerna är presenterad i följande tabell:

```{r echo = FALSE}

exempeltabell <- as.data.frame(table(exempeldata$bil))
colnames(exempeltabell) <- c("Märke", "Frekvens")

kable(exempeltabell, format = "html", caption = "Fördelning av bilmärken i urvalet") %>%
  kable_styling(position = "center", full_width = FALSE)

```

Det som är viktigt är att vi fortfarande i R hanterar denna frekvenstabell som en `data.frame`, då `ggplot` kräver formatet för sina visualiseringar. Datamaterialet ser då istället ut som:

```{r}

head(exempeltabell)

```

För att skapa diagrammet som vi sett tidigare måste vi lägga till några argument i `aes()` och `geom_bar()` likt koden nedan. Argumentet `stat = "identity"` i `geom_bar()` krävs för att R ska räkna värdet på den angivna y-variabeln som höjden på stapeln.

```{r}

ggplot(exempeltabell) + aes(x = Märke, y = Frekvens) + geom_bar(stat = "identity") + theme_bw()

```




##### Färger 
Om vi vill ändra färgen på olika delar av diagrammet exempelvis staplarna kan vi göra detta inuti `geom_bar()` med argumenten `color` för kantlinjerna och `fill` för fyllnadsfärgen. För att se vilka färger som går att ange kan man köra funktionen `colors()` för deras namn eller hämta hem följande [PDF](http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf) som har färgerna utskrivna. Vi kommer senare titta närmare på färger och dess funktion i visualiseringar.

```{r}

p <- ggplot(exempeldata) + aes(x = bil) + 
  geom_bar(fill = "dark orange",
           color = "black",
           aes(y = stat(count/sum(count)))) +
  theme_bw()

p

```


##### Stödlinjer 
Nu vill vi ändra lite stödlinjer så att de syns och hjälper till att förtydliga informationen vi vill visa. När det kommer till stapeldiagram behövs inte stödlinjer på x-axeln då staplarna sträcker sig hela vägen ner till dess skalvärden. Däremot behöver vi förtydliga skalvärdena på y-axeln. För att ändra utseendet på olika delar i ett diagram används `theme()` och diverse olika argument däri. Titta i dokumentationen för funktionen för att få en inblick i vad som kan ändras i diagrammet. Oftast ska dessa delar anges med en utav `element`-funktioner, beroende på typen som ska ändras. Text ändras med `element_text()`, linjer med `element_line()` och delar kan helt och hållet tas bort genom `element_blank()`. Nedanstående kod ändrar stödlinjerna på y-axelns färg till lite mörkare grå än standardvärdet (`panel.grid.major` för stödlinjerna som följer skalvärdena, `panel.grid.minor` för stödlinjer emellan skalvärdena) och tar bort stödlinjerna från x-axeln.

```{r}

p <- p + theme(panel.grid.major.x = element_blank(),
               panel.grid.minor.x = element_blank(),
               panel.grid.major.y = element_line(color = "gray70"),
               panel.grid.minor.y = element_line(color = "gray80"))

p

```

##### Text 
Det som saknas just nu i diagrammet är tydligare (och större) text som förklarar de olika delarna av diagrammet för läsaren. De olika etiketterna kan alla anges i samma funktion genom olika argument likt:

```{r}

p <- p + labs(x = "Bilmärke", y = "Andel", caption = "Källa: Hietala (2019)")

p

```

Det vi kan förhålla oss till när vi anger titeln för y-axeln är att den beskriver enheten som används för att mäta axelns skalvärden. Då vi i detta fall har värden mellan $0$ och $1$ bör vi ange *Andel* som titel. Om vi skulle haft absoulta frekvenser skulle en lämplig titel varit *Antal*. Om vi istället för andelar anger skalan i procent likt tidigare diagram kan det diskuteras huruvida det behövs en y-axeltitel eftersom enheten redan är angiven på skalan. Diagrammet skulle då kunna se ut som:

```{r}

p + scale_y_continuous(labels = scales::percent) + labs(y = "")

```

Vi kan även ändra andra aspekter av textens **utseende** i diagrammet, exempelvis hur stor den är, dess rotation eller position. Detta görs med olika argument i `theme()`. Vi kan ändra utseendet på axeltexter med `axis.title`, skalvärden med `axis.text` och källhänvisningen med `plot.caption`. Alla dessa delar kräver instruktioner från `element_text()`-funktionen och där kan argument som:

- `angle` styra rotationen, 
- `hjust` och `vjust` styra placeringen horisontellt respektive vertikalt, 
- `size` styra textstorleken,
- `font` styra typsnittet,
- `face` ange en eventuell fet- eller kursivmarkering av texten

```{r}

p <- p + theme(plot.caption = element_text(face = "italic"),
               axis.title.y = element_text(angle = 0, vjust = 0.5, size = 11),
               axis.title.x = element_text(size = 11),
               axis.text = element_text(size = 10, color = "black"))

p
```

##### Skalvärden 
Ibland kan de automatiskt genererade axelskalorna medföra svårigheter att utläsa informationen som vi ska presentera. Därför är det sista vi kommer titta på funktioner för att ändra dessa skalor. Vilken funktion vi vill använda och hur man kan ändra utseendet påverkas av vilken sorts variabel som anges på den specifika axeln. Exempelvis kanske vi vill i diagrammet ändra så att den **kontinuerliga** y-axeln endast visar skalvärden var 10:e procent istället för var 5:e som nu sker. Detta gör vi då via:

```{r}

p + scale_y_continuous(breaks = seq(from = 0, to = 1, by = .10))


```

Argumentet `breaks = seq(from = 0, to = 1, by = .10)` anger att vi vill att värden (breaks) ska visas på specifika ställen på axeln. `seq()`-funktionen är ett snabbare sätt att skapa en vektor med lika steglängd mellan värden som vi använder för att skapa `c(0, 0.1, 0.2, 0.3, ..., 1)`. Notera att trots att vi anger värden som går hela vägen upp till 1, kommer inte diagrammet visa detta. 

Om vi skulle vilja visa en större del av axeln kan vi ange skalans gränser med `limits` likt koden nedan. Risken med detta är att vi skapar för mycket onödig tom rityta som minskar utrymmet för den information som vi vill presentera.

```{r}

p + scale_y_continuous(breaks = seq(from = 0, to = 1, by = .10), 
                       limits = c(0, 0.35))

```

Något som dock är snyggt att göra med specifikt stapeldiagram är att ta bort den lilla yta som finns under alla staplar och låta y-axeln möta x-axeln vid `y = 0`. Detta kan vi göra med argumentet `expand = c(0,0)`, men då **måste** vi ange gränserna på skalan. 

```{r}

p <- p + scale_y_continuous(breaks = seq(from = 0, to = 1, by = .10), 
                            limits = c(0, 0.25),
                            expand = c(0,0))
p

```

#### SAS EG 

#### SPSS 




### Grupperat stapeldiagram {.tabset}
Om vi har ett datamaterial bestående av flera kvalitativa variabler kan vi ibland vilja visualisera fördelningen av en variabel **grupperat** på en annan, exempelvis "Hur ser fördelningen av bilmärken ut, uppdelat på civilstånd?". Det kanske finns några intressanta relationer mellan dessa två variabler som vi skulle vilja undersöka vidare, men som tidigare sagt är visualisering alltid det första steget för att lära känna sitt datamaterial.

I vårt exempeldata har vi två kvalitativa variabler, `civilstand` och `bil`. För att visualisera ett grupperat stapeldiagram behöver vi välja en grupperings- och en fördelningsvariabel. Fördelninsgsvariabeln kommer grupperas över varje enskilda kategori från grupperingsvariabeln. 

#### R
I R måste vi ange grupperingsvariabeln likt det vi gjort tidigare som `x` och fördelningsvariabeln som `fill` inuti `aes()`. Detta kommer säga åt R att vardera värde på `bil` ska ha olika fyllnadsfärger. `position = "dodge"` bestämmer att staplarna ska ligga bredvid varandra och `position = "stack"` staplar de ovanpå varandra för ett s.k. stackat stapeldiagram. 

```{r fig.height = 4}

p <- ggplot(exempeldata) + 
  aes(x = civilstand, fill = bil) + 
  geom_bar(position = "dodge") + 
  theme_bw()

p 
```

För relativa frekvenser i ett grupperat stapeldiagram kan vi summera de visualiserade staplarna på två olika sätt. 

1. Antingen visar vi relativa frekvenser utifrån hela datamaterialet. Detta diagram kommer se exakt likadan ut som den med absoluta frekvenser men med andelar istället för antal. Vi använder samma kod som för det enkla stapeldiagrammet: `aes(y = stat(count/sum(count)))`.

```{r fig.show = "hide"}

ggplot(exempeldata) + aes(x = civilstand, fill = bil) + 
  geom_bar(aes(y = stat(count/sum(count))), 
           position = "dodge") + 
  theme_bw()

```

2. Alternativet är att visa den relativa fördelningen grupperat på grupperingsvariabeln, alltså att vardera kategoris staplar summerar var för sig till 100 procent. Vi behöver då revidera koden som anger beräkningen till relativa frekvenser till: `aes(y = stat(count/tapply(count, x, sum)[x]))`.

```{r fig.show = "hide"}

ggplot(exempeldata) + aes(x = civilstand, fill = bil) + 
  geom_bar(aes(y = stat(count/tapply(count, x, sum)[x])), 
           position = "dodge") + 
  theme_bw()

```

```{r echo = FALSE, fig.width = 8, fig.height = 4, fig.cap= "Grupperat stapeldiagram med enkel summering (t.vä.) och gruppvis summering (t.hö.) till 100 procent"}

p1 <- ggplot(exempeldata) + aes(x = civilstand, fill = bil) + 
  geom_bar(aes(y = stat(count/sum(count))), position = "dodge") + 
  theme_bw()

p2 <- ggplot(exempeldata) + aes(x = civilstand, fill = bil) + 
  geom_bar(aes(y = stat(count/tapply(count, x, sum)[x])), position = "dodge") + 
  theme_bw()

grid.arrange(p1, p2, nrow = 1)

```

Tolkningarna på vardera av dessa diagram skiljer sig åt och valet styrs av vilken sorts frågeställning som vi vill besvara med visualiseringen. En jämförelse av gruppernas fördelning skulle bli tydlig med en gruppvis summering, medan presentation av fördelningen i materialet kan visualiseras med den enkla summeringen.

##### Förtydliga diagrammet
Oavsett vilket sätt att summera staplarna som används ser de inte alls tydliga ut. Vi förtydligar till diagrammet med liknande hjälpfunktioner som tidigare stapeldiagram. Vi lägger till tydligare kantlinjer på staplarna, lägger till stödlinjer och etiketter, samt justerar utseendet på diverse texter samt ändrar skalan för y-axeln.

```{r fig.height = 4}

p <- ggplot(exempeldata) + 
  aes(x = civilstand, 
      fill = bil) + 
  geom_bar(aes(y = stat(count/sum(count))), 
           position = "dodge",
           color = "black") + 
  theme_bw() + 
  theme(panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        panel.grid.major.y = element_line(color = "gray70"),
        panel.grid.minor.y = element_line(color = "gray80"),
        plot.caption = element_text(face = "italic"),
        axis.title.y = element_text(angle = 0, vjust = 0.5, size = 11),
        axis.title.x = element_text(size = 11),
        axis.text = element_text(size = 10, color = "black")) +
  labs(x = "Civilstånd", 
       y = "Andel", 
       caption = "Källa: Hietala (2019)") +
  scale_y_continuous(expand = c(0,0),
                     breaks = seq(0, 0.20, by = 0.05),
                     limits = c(0, 0.16))

p

```

##### Färger
Det som också urskiljer ett grupperat stapeldiagram med det skapades tidigare är att vi nu har en legend till höger av diagramytan som innehåller ytterligare information som krävs för att läsa av diagrammet. Vi har fått olika färger på den valda fördelningsvariabeln som kopplas samman till de olika kategorierna. Dessa vill vi nu ändra tillsammans med att ändra lite information i legenden för att göra den tydligare.

För att skapa ett diagram som har en enhetlig och tydlig färgpalett kommer paketet `RColorBrewer` till användning. Ladda paketet med `require(RColorBrewer)` och titta på de olika färgkategorierna som finns att använda genom `display.brewer.all()`. Det rekommenderas att välja någon av de monokromatiska färgskalorna likt `"Oranges"` eller `"Purples"`.

För att revidera utseendet på legenden och de använda färgerna används funktionen `scale_X_manual()` där `X` ersätts med den sorts gruppering som har gjorts för att skapa legenden, i detta fall `fill`. I `values` anges vilka färger som ska användas i diagrammet och där vill vi då använda någon palett från `RColorBrewer` genom `brewer.pal()`-funktionen. Argumentet `n` anger hur många färger vi vill ha och `name` anger vilker palett vi vill ta färgerna från.

```{r fig.height = 4}

p <- p + scale_fill_manual(name = "Bilmärke",
                           values = brewer.pal(n = 8,
                                               name = "Oranges"))

p

```

#### SAS EG

#### SPSS

### Histogram {.tabset}
Om variabeln istället är kvantitativ och vi vill presentera fördelningen av denna variabel, är histogram (eller lådagram) lämpligt att använda.

#### R
Likt tidigare diagram i R behöver vi först ange vilket datamaterial samt vilken variabel som vi ska visualisera. 

```{r}

p <- ggplot(exempeldata) + aes(alder)

```

När väl det är gjort måste vi på samma sätt som tidigare ange vilken form av visualisering som ska göras. För histogram använder vi `geom_histogram()`, med argumentet `bin` som styr hur många klassintervall vi vill ha. Om vi istället vill ange hur breda intervallen ska vara kan vi använda argumentet `binwidth`.

```{r}

p <- p + geom_histogram(fill = "orange", 
                        color = "black",
                        bins = 10)

p

```

Vi kan också snygga till diagrammet med alla funktioner som vi tidigare använt för stapeldiagram.

```{r}
p <- p + scale_y_continuous(expand = c(0,0), limits = c(0, 20)) +
  theme_bw() + theme(axis.title.y = 
                       element_text(angle = 0, 
                                    hjust = 1, 
                                    vjust = 0.5), 
                     plot.title = 
                       element_text(hjust = 0.5),
                     panel.grid.major.x = 
                       element_blank(),
                     panel.grid.minor.x = 
                       element_blank(),
                     panel.grid.major.y = 
                       element_line(color = "dark gray")) + 
  labs(y = "Antal", 
       x = "Ålder", 
       title = "Fördelning av ålder", 
       caption = "Källa: Hietala (2019)")

p
  
```

#### SAS EG

#### SPSS

### Lådagram {.tabset}
Ett alternativ att presentera fördelningen för en kvantitativ variabel är lådagram. Denna visualiseringstyp lämpar sig bättre om det finns extremvärden i materialet då diagrammet utgår ifrån kvartiler.


#### R
Vi börjar strukturera ett lådagram på samma sätt som vi gjorde med histogrammet, dock behöver vi använda ett knep för att R ska skapa ett snyggt diagram. I `aes()` måste `x = factor(0)` som är ett sätt för R att skapa en tom kategorisk variabel. Lådagrammet skapas med `geom_boxplot()`.

För att ta bort onödiga skalvärden och axelförklaring för den tomma variabeln som vi skapat används värdet `NULL` på de argument som vi vill ta bort, exempelvis `breaks` i `scale_x_discrete()`.

```{r}

p <- ggplot(exempeldata) + aes(x = factor(0), y = alder) +
  geom_boxplot(fill = "orange") +
  scale_x_discrete(breaks = NULL)

p

```

Snyggar till diagrammet som tidigare.

```{r}
p <- p + theme_bw() + theme(axis.title.y = 
                              element_text(angle = 0, 
                                           hjust = 1, 
                                           vjust = 0.5), 
                            plot.title = 
                              element_text(hjust = 0.5),
                            panel.grid.major.x = 
                              element_blank(),
                            panel.grid.minor.x = 
                              element_blank(),
                            panel.grid.major.y = 
                              element_line(color = "dark gray")) + 
  labs(y = "Ålder", 
       x = NULL, 
       title = "Fördelning av ålder", 
       caption = "Källa: Hietala (2019)")

p

```


#### SAS EG

#### SPSS

### Linjediagram {.tabset}

#### R

#### SAS EG

#### SPSS

### Andra diagram

#### Cirkeldiagram

#### Stjärndiagram / Radar chart

## Samband mellan variabler

### Spridningsdiagram {.tabset}

#### R

#### SAS EG

#### SPSS


# Referenser